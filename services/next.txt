  В Нексте то что находится в head, именно в title будет иметь приоритет то что приходит последние(то что импортируем в файл) в нашем случае мы импортируем index.tsx в _app.tsx по-этому приоритет у index.tsx будет больше потому что он импортируется и соотвественно его код последний. Но с link не так не, link в Head будут компилироваться вместе.
    Мы можем с помощью key={число} как только next будет рендерить компонент он два линка в которые мы записали key={} к примеру в _app.tsx у нас <link key={1} rel="icon" href="favicons" />
и так же в index.tsx есть <link key={1} rel="icon" href="favicons" /> он эти два линка смёрджит по ключу и будет использовать по аналогии с title последний неопределенный, таким образом у нас останется последний icon а именно с index.tsx, так мы можем не добавлять свойства к друг-другу, а переопределять их

    Возможность переопределять всего документа. Наш html тег в браузере сейчас не содержит никакой спецификации по языку, что не хорошо, например скринридеры когда будут читать данный документ
могут не понять что это за язык, по-этому всегда нужно указывать language. Создадим _document.tsx что бы переопределить наш документ. После того как мы создали файл _document.tsx и там все прописали с документации у нас обок html появился lang=ru. ТЕ вся фциональность у нас сохранилась, но мы костомизировали сам документ что бы прокинуть туда lang


Переменные окружение !

Часто нам нужно будет передавать какие-то переменые для исполнение на сервере либо на клиенте, например это будет домен на который мы будем отправлять запрос, почему это необходимо переменных окружения, потому что домен на тесте, домен локальный и домен на продакшене могут не совпадать, по-этому мы можем создать файл .env.local, в нем указать переменную окружение домен какую-то строку, и она будет доступна у нас в приложение по пути process.env.DOMAIN , а cам DOAMIN = https://owltop.ru к примеру. 
Аналогично можно передавать любые другие переменные, например если наше приложение на Некст на прямую входит в базу во время Сервер Сайд Рендеринга, то мы тоже сможем это сделать используя соотвествующие переменное окружение.

  Кроме этого мы можем использовать ссылки на другие переменные, которые были объвлены ранее :
MY_PORT=3000
MY_HOSTNAME=localhost
MY_HOST=http://$MY_HOSTNAME:$MY_PORT //ссылка на переменную

  Существуют различные файлы .env
.env - для всех окружений. Это то что должно содеражать абсолютно все и продакшен и тест и разработка. Он должен быть прозрачен
.env.local - локальная разработка(тут все секерты) и она в gitignore. К примеру здесь можно хранить пароль от базы данных
.env.development - для dev окржения (npm run dev)
.env.production - для prod окружение (npm start)
.env.test.local - для окржения запусков теста(тут все секреты) и тоже gitignore. Все тоже самое что и в .env.local только для тестевого окружения
.env.test - для окржения запусков теста

Все переменные которые мы объявили с .env будут доступны в рамках Сервер Сайд Рендеринга !
Если мы хотим что бы в рантайме уже на клиенте эти переменные тоже был доступны то на нужно сделать приставку NEXT_PUBLIC_ тем самым говоря для Некста что помимо того что эту
переменную нужно иметь на сервере, она будет переданна на клиент для того что бы мы могли там ее использовать

Создадим файл .env.local 
Здесь нам необходим публичный домен, то-есть не только то что мы будем использовать в рамках ССР, а и на клиенте что бы потом делать запрос 
NEXT_PUBLIC_DOMAIN=https://owltop.ru - эта строка поможет нам получить АПИ к этому сайту, он писал ее в курсе по НОДЕ



Как работает SSR ?
Это понимание очень важно что бы знать какие данные у нас будут индексироваться, а какие данные у нас прилитают на клиент только после того как приложение само уже заинициализировалось

Процесс рендеринга браузером
Когда мы заходим на какой-то сайт, наш браузер получает html, в html он видит все зависимости в виде css, scripts. В первую очередь он грузит css и только когда html и css готовы - он может отображать, а js просто как вспомогательныей скрипт для работы странички
Но в соверменных реалиях фреймворком, мы можем отображать после того как bundle вместе с Реактом, Ангуляром или Вью, прилетел к нам на клиент, распарсился, отрендерился и соотвественно у нас готова страница

Сравнение SSR и CSR(client side rendering)
Начнем разбор с CSR
Сначала мы получаем запросс что нам нужно зарендерить сайт и мы получаем сначала 1)пустой html 2)загуржает css 3)загружает js 4)парсит и исполняет ДжаваСкрипт 5)рендерит на клиенте соотвественно дерево которое построило ДжаваСкрипт и у нас страница готова к отображение и работе
Теперь процесс SSR !
1) При поступление запросса - рендер происходит на сервере(то-есть сервер рендерит наш html)
2) HTML с клиентом уже возвращается к нашему клиенту(мы уже видим готовый html с контентом)
3) Подгружается css 
4) Cайт уже полностью готов для того что бы мы могли его видеть(то-есть сайт уже отрендерился)
5) После того как сайт отрендерился у нас идет запрос и получение JavaScript
6) JavaScript парсит и исполняется
7) И в конце происходит Гидротация приложения 
Таким образом благодаря SSR мы получаем намного быстрее скорость отображние сайта 
Здесь у нас возникает проблема, что для того что у нас выполняет браузер на клиенте, у нас это все должен выполнить сервер

Что такое Гидротация приложения ?
Когда у нас возвращается первый рендеринг сервиса, у нас получается только html и какие-то начальные данные, на которых этот html строится(наши продукты на странице, какие-то общие вещи)
Дальше когда у нас приходит js, ему нужно из этой статической страницы сделать динамическое приложения(добавить какой-то логики). Была бы проблема что после того как прилетела полностью html, js сносил бы весь дом и строил бы его заново, по-этому есть процесс Гидротации - в рамках которого js проходится по html, добавляет недостоющие обработчики, методы, иногда перестраивает какие-то элементы и визуально сайт для клиента не меняется, но внутри - этот сайт уже является полноценным приложением Реакта. Все это возможно благодаря V8 на Бек-енде на нашем Node.js. То-есть наш SSR происходит с помощью движка Ноды и того движка что у нас есть в Хроме

Минусы SSR
1) Рендер на севрере на каждый запрос !!! Если представить что у нас одновременно пару тысяч пользователей запросили нашу страницу. То у нас сервер должен уметь отрендерить одновременно 10000 страниц. По-этому в ССР в большинстве случае используется Кеширование, за исключением когда нам нужны действительно динамические данные
2) Страница полностью рабочая только после исполнения js
3) Более сложная настройка. В самом Реакте тоже можно настроить ССР, но это гемор. По-этому мы используем Фреймворк Next.js 
4) Полная перезагрузка страницы при смене route. Представис что у нас есть страница /about, мы на нее нажали и нам сервер ее зарендерил и отдал, если мы захотим пойти на route /info то мы заново получим новый html и произойдет Гидротация приложения. То-есть вместо плавных переходов и загрузки данных которые мы получаем в single page application, то здесь мы получаем полную перезагрузку страницы

Плюсы SSR
1) SEO friendly. Антон сказал что в компании занимается SEO-оптимизацией, и SSR катастрофически хорошо влияет на SEO. Потому что мы даем а) производительность б) лучший овтет сервера в)отсутсиве костылей для того что бы индексировать сингл пейдж апликейшенами(это все можно и делать в single page application но ССР делает это на порядок лучше)
2) First Contentful Paint - намного быстрее, первая отрисовка очень быстрая что сильно поднимает конверсию
3) Огромный прирост производительности на слабых устройствах, из-за того что у нас ренедер происходит на севрере

Сравнение SEO в CSR и SSR
CSR:
Когда приходит Запрос на nginx мы можем понять по юзер-агенту бот это или пользователь, если это пользователь, то мы даем ему single page application и он загружается, если это Бот то мы отправляем наш запрос на серверс при Рендеринга, который заходит на наше single page application, исполняет его, генерит html и выдает обратно(то-есть выполняет некую функцию СерверСайдРендеринга), минус такого процесса что времени за тем как сделали запрос, и отдает прирендер - это в районе 4-5 секунд(по-этому здесь тоже обычно делают кеширование)
SSR:
Если мы делаем ssr то такого кастыля не нужно. 
Запрос -> nginx -> app
После того как приходит запрос нам все равно бот это или юсер, мы все равно выдаем ему приложение

Что решает NextJS ?
Кроме того что это готовый Фреймворк с ssr который ускоряет разработку, он дает еще две готовые опции
1) Честный SSR, когда на каждый запрос мы можем действительно рендерить страничку в режиме рантайм(это редкая опция, потому что появилась возможность инвалидация кеша)
2) Cache(кеш). Когда мы на этапе билда(еще только мы выкладываем приложение), мы проходимся по всем готовым Роутам, вытаскиваем оттуда инфомрацию, рендерим страницы, и у нас есть в Кеше все возможные странички нашего сайта. Если вдруг что-то обновилось то есть инвалидация Кеша, которая позволяет нам полностью перерендерить страничку уже не на этапе сборки, а на этапе работы самого NextJS. Кроме этого если у нас блок с 10000 записи, то билдтайм с таким будет достаточно большим, этим страдают другие фреймворка типа элевенти, гетсби, где нам необходимо всегда зарендерить каждую страничку. Некст это тоже решает, потому что мы можем не рендерить все Роуты, а рендерить их по запросу. Один раз происходит СерверСайдРендеринг уже в рамках работы приложение NextJS и Кеш складывается вместе с остальными страницами

Производительность
В десктопе nextjs быстрее на 35 процентов
А мобилка в на 60 процентов
Это нам говорит что впринципе для десктопа это не совмем проблема, но много пользователей с слабыми мобилками, что значит что nextjs идеальный выход с этой ситуации
Загрузка первичного приложение больше в 2-3 раза. Скорость работы тоже в 2-3 раза

CSR лучше использовать для внутреннего кабинета или что-то где нам нужно строить дешборды(какие-то такие вещи), то тогда лучше CSR, потому что нам не критично время загрузки, во-вторых мы можем сделать его более плавным, хорошая анимация, красивые переходы



Как работает SSR в NextJS
У НекстJs есть Две формы пререндера
1) Static generation. Где мы предварительно генерируем статический контент, который потом отдаем
2) Server Side rendering. На каждый запрос мы срендерим страницу и отдаем ее

Функции для получение данных
Для Static generation :
function getStaticProps() { }
function getStaticPath() { }

Для SSR:
function getServerSideProps() {}

Важное замечание ! Каждая из этих функций исполнятся будет только на Сервере, на клиенте их не будет. Во-вторых мы можем использовать эти функции исключительно на страницах, то-есть не сможем использовать не в Компонентах, не в НОС, но только на страницах, потому что это специфика НекстJs

Статическеая Генерация
1) getStaticProps - позволяет получить данные для генерации нашего шаблона, потому что наши шаблоны сильно завязанны на данных которые нам прийдут из АПИ. 
Во-первых,Ее необходимо использовать когда у меня уже доступные данные, из которых мы можем сгенерить страницу пряму на этапе сборки. 
Вторая ситауия где ее можно использовать - это когда у нас нет каких-то специфических layoutов страниц в зависимости какой пользователь туда зашел, те это какие-то публичные страницы единобразные для всех(по крайней мере та часть которая будет ssr должна быть не персонализированная)
Третьих страница должна быть доступная для индексирования, тогд мы используем getStaticProps
Как выглядит getStaticProps
function Page ({ res }: InterGetStaticPropsType<typeof getStaticProps>): JSX.Element {
  return <></> //здесь мы видим туже страницу которая ничего не возвращает
}
export default Page

export const getStaticProps: GetStaticProps<IPageProps> = async ({ params }): GetStaticPropsContext<ParseUrlQuery>) => {
  const res = await fetch('https://...')
  return {
      props: {
          res,
      },
  }
}
interface IPageProps {
  res: Response
}

Здесь мы же экспортируем функцию getStaticProps. Она возвращает специальный тип GetStaticProps, с Дженериком куда мы можем передеать тип Пропсов. На вход она принимает некоторый контекст и этот контекст ({ params }) типа GetStaticPropsContext, все это экспортируется из Next, крмое ParseUrlQuery она экспортируется из node
Дальше мы выполняем логику получение данных  const res = await fetch('https://...'). Те мы сходим на Бек(все равно с помощью какой библотеку, аксиос к примеру), получаем с бека что-то и помещаем результат в res. В результате мы возвращаем Пропсы, которые потом автоматически передаются в нашу страницу function Page ({ res }. Этот res будет нам доступен на странице
А в interface мы уже объявляем тип пропсов что бы мы не передали в res всё что угодно

Теперь остановимся на Контексте, который приходит в эту функцию ({ params })
export type GetStaticPropsContext<Q extends ParseUrlQuery = ParseUrlQuery> = {
    params?: Q //параметры Роута, если страница вида [id].tsx
    preview?: boolean //тип если страница находится в режим preview
    previewData?: any //данные для превью
    locale?: string //данные о языке для мультеязычных сайтов
    locales?: string[] //все поддерживаемые языки
    defaultLocale?: string  //язык по умолчанию
}
params - если у нас роут динамический(у нас есть айдишник к примеру или Алиес), все что угодно, те динамическая страница с Роутингом, то параметром будет содержатсья этот Роутинг
preview - это специальный мод в НекстJS, когда мы можем сказать что страница пожалуйста зарендерься и покажи как ты будешь выглядить с некими ПревьюДанными, но не проводи, пожалуйста статическую генерацию. То-есть это место когда мы хотим превьюить страницу. к примеру в админке мы хотим видеть как будет выглядить пост перед публикацией то нам preview прийдет как true а previewData -  данные для отоброжения поста
NextJS позволяет нам сделать мультиязычный сайт достаточно просто, мы можем в НекстКонфиге указать все locale которые у нас присутсвтуют, к примеру ru, en. Вот эти данные нам будут приходить в locale что бы мы понимали когда и какие из этих данных нам нужно получить. locale - текущий, locales -  массив всех, defaultLocale - дефолт

Возвращаемые параметры
return {
    props: { --> данны для страницы, то из чего мы будем собирать страницу
      res,
    },
    revalidate: 5, --> число секунд, после которых произойдет перегенерация страницы. Ревалидация - это как раз та штука которая отличат Некст от того же Гатсби. 5 секнуд - это время    через которое произойдет заново статическая генерация нашей страницы. Если у нас обновились данные, они обновятся и на статической странице, именно это позволяет нам видить изменение в течение времени, без полной перегенерации всего проекта. Ревалидация называется Инкрементальная Статическая Генерация - после выкладки приложения, страницы с заданным временем ревалидации будут генериться заново(или первый раз если ранее страницы не было), подтягивая новый контент
    redirect: { -->  опция для перенаправления пользователя
      destination: '/',
      permanent: false,
    },
    notFound: true --> возврат 404 страницы вместо запрашиваемой
}


getStaticPath
Статические пути неразрывно связанны с статическими пропсами, потому что позволяют получить пути страниц для генерации этих Пропсов
Нужно использовать для рендера страниц с динамическими адрессами !

export const getStaticPath: GetStaticPath = async () => {
    return {
      path: ['/route1', '/route2'], //генерация путей, к примеру мы сходили в базу и получили все id нужных нам товаров на нашем интернет магазине. Это позволяет на этапе билда понять нашему Нексту по каким страницам нужно пройтись, для того что бы их пригенерить и положить в статическую генерацию
      fallback: true //пробоавать ли рендерить страницу если пути нет среди path. Представь что мы получили 10 айдишников и отерендерили наш сайт, но потом через админку у нас появился 11 товар и кто-то попробовал попросить по пути 11 айдишника и если fallback в тру то Некст будет генерить еще раз эту страничку и тоже класть ее в Кеш. То-есть он позволяет нам ревелидаейт тру создавать статическую генерацию для страниц, которых даже еще не было на этапе билдтайма
      'blocking' - для ожидания рендеринга и потом вернет страницу
    }
}
GetStaticPath - тип возвращаемых props

Если несколько параметров то меняем path:
return {
      path: [{ params: { id: 'route1' } }], //Представим что у нас есть категория товаров и айдишник товаров и путь складывается category/id
      fallback: true
}

Благодаря fallback и начинается магия NextJS. Благодаря ему если мы будем использовать fullback: true вместе с revalidate, то мы получаем неограниченное число страниц, которые нас никак не ограничвают на этапе сбокри. ТЕ если у нас миллион товаров, то мы можем собрать популярные 1000, а все остальные при первом же запросе будут Фуллбечится(fallback), потом генериться, потмо класться и ревалидироваться в случае если что-то поменялось. И это всё нам позволяет создавать не статические сайты, а действительно имеют динамические данные, на которые обновляются через админку, появляются у нас на сайте и мы можем ими динамически управлять без всякого билда. А если у нас очень много страниц то мы можем поставить ограничение путей билда , что бы билд не занимал 20-30 минут, а был достаточно быстрым


Теперь поговорим про SSR, именно про getServerSideProps 
Это честный СерверСайд который выполняется для каждого запроса, пригодится он в том случае если мы хотим зарендерить на сервере, которая зависит от входным персональных данных. К примеру у нас есть jwt token у пользователя и мы хотим ему сделать персональную подборку товаров и тогда если мы хотим это прирендерить - нам нужно использовать СерверСайд пропс

export const getServerSideProps: GetServerSideProps = async (context: GetServerSidePropsContext<ParsedUrlQuery>)=> {
  return {
      props: { --> данные для страницы
          res: 1,
      },
      notFound: true, --> возвращает 404
      redirect: { --> перенаправление
        destination: '',
        permanent: true
      }
  }
}
GetServerSideProps - тип возвращаемых Пропсов
GetServerSidePropsContext - дополнительные параметры

Обрати вниание что он здесь возвращает все те же параметры, за исключение Ревалидейт, потому что мы здесь не можем ничего ревалидировать по приччине того что мы будем выполнять эту функцию getServerSideProps на каждый запросс пользователя
Нужно заметить ! что она дорогостоящая, по-этому если мы можем как-то персонализировать страницу нам не критично для индексирование, не критично для пользовательского опыта, то эту персонализацию страницы мы можем уже вытащить в работу на Клиенте а не заниматься этим на ССР

Расмотрим Контекст
export type GetServerSidePropsContext<Q extends ParseUrlQuery = ParseUrlQuery> = {
    req: IncomingMessage & {
      cookies: NextApiRequestCookies  --> объект запросса к http. Мы можем посмотреть хеддеры, подтянуть куки и по ним построить нашу страницу
    }
    res: ServerResponse --> Объект ответа от сервера
    params?: Q //параметры Роута, если страница вида [id].tsx
    query: ParsedUrlQuery, --> Квери параметы запроса если они содержатся
    preview?: boolean //тип если страница находится в режим preview
    previewData?: any //данные для превью
    resolvedUrl: string --> Нормализование версии url по которому прошел запрос
    locale?: string //данные о языке для мультеязычных сайтов
    locales?: string[] //все поддерживаемые языки
    defaultLocale?: string  //язык по умолчанию
}
Самое важное что здесь хранится полностью Объект запроса и благодаря нему мы можем сделать более полную генерацию взависимоти от параметров пользователя

Итого: для большинства кейсов нам подойдет обычная статическая генерация, потому что она покрывает большинство кейсов того что необходимо индексировать. Если у нас есть совсем персонализированная вещь, то нам подойдет ССПропс - нужно стараться его максимально не использовать ! Потому что чем больше пользователей прийдет на сайт тем больше нагрузка на сервер потому что для каждого пользователя мы должны выполнить рендеринг, а с точки зрения статических пропсов - мы просто будем отдавать статичиские пропсы что безумно дешево !


// Link
Link импортируем из next/link
Благодаря Link у нас не будет перезагрузки страницы после нажитие на ссылку, то-есть не будет нового перерендеринга, все будет плавно. 
При чем мы оборачиваем наш a в Link что значит что для поисковых роботов все будет понятно

export declare type LinkProps {
  href = Url //путь куда навигировать
  as?: = Url //путь для отображение в браузере
  replace?: boolean //заменять ли текущий элемент хистори, что бы пользователь мог нажать на стрелочку назад и его либо перекинет на пред страничку или нет
  scroll?: boolean //скролить ли страницу для верха во время перехода
  shallow?: boolean //запускать ли getServerSideProps и др.
  passHref?: boolean //прокидывать ли href до child
  prefetch?: boolean //предзагрузка данных страницы
}

<Link href={`/courses/design`}> <a>Ссылка</a> </Link>

Прокидывание ref
<Link href={`/courses/design`} passHref>  //passHref - прокидывание href
  <MyOtherComponent />
</Link>

const MyOtherComponent = React.forwardRef<HTMLAnchorElement, HTMLProps<HTMLAnchorElement>>(({ href, onClick }, ref) => {
  return <a href={href} onClick={onCLick} ref={ref} >
    Click me
  </a>
})
forwardRef - для функциональный компонентов
HTMLAnchorElement - тип элемента


// useRouter
Это исключительно хук NextJS, не Реакт. Тот useRoter что находит в react-router-dom никак не связан с Некстовским
const router = useRouter()

export declare type BaseRouter {
  route: string; // текущий роут на котором мы находимся
  pathname: string; // текущий путь на котором мы находимся
  query: ParsedUrlQuery; //  query параметры
  asPath: string; // как путь будет называться при переходе на линк
  basePath: string; //базовый путь
  locale?: string;
  locales?: string[];
  defaultLocale?: string;
  domainLocales?: DomainLocales;
  isLocaleDomain?: boolean;
}

Методы и события для управление useRouter
Pick <Router
'push'
| 'replace'
| 'reload'
| 'back'
| 'prefetch' //мы можем загрузить данные для какого-то специального Роута, например по какому-то событию
| 'beforePopState' // коллбек, который будет вызываться, перед тем как будет происходить переход
| 'events'
| 'isFallback'
| 'isReady'
| 'isPreview'>


//
Компонент Image 
Этот Компонент позволяет нам Кешироавть и Генерить файлы - это значит что как только мы добавляем компонент Image он всходит в источник этого Image, либо возьмет его из папки если он распологается локально, либо на ДОМЕН, потом возьмет это изображение, сгенерирует необходимые форматы и размеры и после этого будет сервить это всё из своего Кеша
<Image
    quality={70} - качествок которое мы допускаем для сжатия нашего изображение. Потому что все изображение передаваемые в image будут обрабатываться и оптимизироваться
    priority={false} - позволяет делать preload если оно в Тру(если какое-то важное изображение в Шапке), и нам важно что бы он первый загрузился
    src="./png" - исходный файл, как локально так и в домене
    width={70} - размеры мы передаем в ручную за исключением если layout='fill'
    height={70}
    layout='fixed'
    objectFit='fill'
    objectPosition='left buttom'
    loading='lazy' - стоит по-дефолту, для оптимизации
    unoptimized={false} - оптимизировать ли картику ?
    loader={myLoader} - свой загрузчик изображений

Различные Layout:
1) fixed - если изображений не меняется при адаптиве
2) intrinsic - для меньших разрешений отображений будет снижаться
3) responsive - для меньших разрешений отоборажений будет снижаться а для больших расстягиваться
4) fill - будет расстягиваться до границы parent элемента

Свой загрузчик
const myLoader = ({ src, width, quality }: ImageLoaderProps) => {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}

Настройки размеров
images: {
  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], //размеры для генерации
  imageSized: [16, 32, 48, 64, 96, 128, 256, 384],
  domains: ['example.com'] //доступные домены для загрузки
}