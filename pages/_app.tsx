import '../styles/globals.scss';
import Head from 'next/head';
import Router from 'next/router';
import React from 'react';
import { AppProps } from 'next/dist/shared/lib/router/router';
import ym from 'react-yandex-metrika';
import { YMInitializer } from 'react-yandex-metrika';

Router.events.on('routeChangeComplete', (url: string) => {
	if (typeof window !== 'undefined') {
		//Проверяем что мы НЕ на сервере
		ym('hit', url);
	}
});
function MyApp({ Component, pageProps, router }: AppProps): JSX.Element {
	return (
		<>
			<Head>
				<title>MyTop - наш лучший топ</title>
				<link rel="icon" href="/favicon.ico" />
				<link rel="preconnect" href="https://fonts.gstatic.com" />
				<link
					href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
					rel="stylesheet"
				/>
				<meta property="og:url" content={process.env.NEXT_PUBLIC_DOMAIN + router.asPath} />
				<meta property="og:locale" content="ru_RU" />
			</Head>
			<YMInitializer accounts={[]} options={{ webvisor: true, defer: true }} version="2" />
			<Component {...pageProps} />
		</>
	);
}

export default MyApp;

////<meta property="og:url" content={page.} />  что бы сформировать url на данную страничку. Из-за того что og:url у нас может определяться в одном месте, мы вынесим его отсюда в наш Компонент App, потому что у нас есть оставшиеся og-теги, они будут расспростроняться на все странички. Во-первых это будет url, мы его можем получить так как это наш Домен - content={process.env.NEXT_PUBLIC_DOMAIN}
// <meta property='og:url' content={process.env.NEXT_PUBLIC_DOMAIN + router.asPath}/> тем самым мы получаем полный путь до текущей странички которая будет рендерится, эта мета будет формироваться на этапе прирендера, потому что ниже - Компонент нашей странички <Component {...pageProps} />
//og:type - тип странички что бы описать что это, добавив в страницу с Алиасом

//
//Сюда нужно подключать реакт-гугл-метрику, потому что здесь у нас ведется работа со всеми метриками
//нам нужно подписатья на изменение Роутера, когда изменяется Роутер то мы должны давать хит,но только если мы не находимся на СерверСайдРендеринге
//router.events.on('routeChangeComplete') там есть много вариантов, но нас интересует когда изменение на нашей страничке уже произошло, всё это можно почитать в документации Некста, там есть перечень всех евентов на которые мы можем подписаться
//мы подисываем на изменения роута и при каждом изменение роута мы будем отправлять в яндекс метрику событие что мы успешно захитились

//так же нам нужно инициализировать нашу метрику что бы библиотека встроила код метрики в наше приложение.Для этого импортируем YMInitializer

//
// В Нексте есть возможность отделить наши статитически сгенерированные страницы, от самого движка Некст и выдавать их пользователю с помощью CDN или Еджинкса, что быстрее чем обычная выдача через сервер Некста, для нашего приложения это не подойдет потому что как только мы пытаемся экспортировать все наши статичиски сгенерирвоанные страницы - это значит что мы не можем воспользоваться преимуществами фоллбеков(ревалидации страницы), когда данные на беки у нас обновляются а на Фронте так же обновляется за счет этой ревалидации, когда мы экспортируем контент - мы фактически экспортируем набор статических страниц, кроме этого у нас не получитс использовать имедж который мы разбирали до этого, потому что для статически сгенерированого контента должен быть облачный генератор изображений, который будет оптимизировать наше изображения, но что бы понимать возможности Некста - мы в любом случае это приложение экспортируем и посмотрим как оно работает
/*router.events.on('routeChangeComplete', (url: string) => {
		if (typeof window !== 'undefined') {
			ym('hit', url);
		}
}); 
При статической генерации мы должны подписываться не на этот Роутер, а импортировать Router с Некста и уже подписатсья на изменения этого Роутера и вынести его за страницу MyApp !*/
