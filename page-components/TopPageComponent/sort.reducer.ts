import { SortEnum } from '../../components/Sort/Sort.props';
import { ProductModel } from '../../interfaces/product.interface';

export type SortActions =
	| { type: SortEnum.Price }
	| { type: SortEnum.Rating }
	| { type: 'reset'; initialState: ProductModel[] };

export interface SortReducerState {
	sort: SortEnum;
	products: ProductModel[];
}

export const sortReducer = (state: SortReducerState, action: SortActions): SortReducerState => {
	switch (action.type) {
		case SortEnum.Rating:
			return {
				sort: SortEnum.Rating,
				products: state.products.sort((a, b) => (a.initialRating > b.initialRating ? -1 : 1)),
			};
		case SortEnum.Price:
			return {
				sort: SortEnum.Price,
				products: state.products.sort((a, b) => (a.price > b.price ? 1 : -1)),
			};
		case 'reset':
			return {
				sort: SortEnum.Rating,
				products: action.initialState,
			};
		default:
			throw new Error('Неверный тип сортировки');
	}
};

// сначала объявие екшены которые вообще будут доступны

// SortReducerState в этом стейте должна хранится сама сортировка, потому что нам по этой сортировке правильно отображать текущее состояние - sort: SortEnum и второе это отсортированный массив продуктов products - то-есть у нас есть входящий пропс, а здесь будет хранится стейт который формируется на основе входящего Пропса и сортировки

// функция редьюсер принимает текущий стейт и екшен и возвращает измененный стейт
// Если в кейс приходит SortEnum.Rating то мы сортируум массив продуктов по рейтингу, а именно смещая сверху вниз по рейтингу продукты

//
// Когда мы переходим по странички допустим Аналитики, то у нас загружается страница аналитика но визуальная часть не меняется и остается та же(то-есть продукты не меняются), но когда обновляем страницу то все нормально и продукты меняются на корректные. Когда мы обновляем страницу - мы воспользовались статическим кешом который у нас сгенерил Некст, именно по-этому здесь все корректно, а когда мы двигаемся от страницы к странице - мы используем клиентский роутинг, в рамках этого клиентского роутинга наш Некст работает как обычное Реакт приложение, по-этому если мы посмотрим здесь на useReducer, то мы всегда используем начальное значение продуктов которое было переданно  useReducer(sortReducer, {  .По-этому у нас поменялась страничку, но начальны продукты у нас никак не переделались, потому что useReducer уже работает, по-этому нам нужно сделать подписку на изменения этих продуктов, то-есть если поменялись продукты, то мы должны поменять и стейт, сейчас этого не происходит потому что один раз был инишиалСтейт в рамках продукта, то-есть мы после того как получили один раз продукты, у нас initialState уже никак не будет рабоать
// В нашем sort.reducer создаём { type: 'reset', initialState: ProductModel[] } тем самым мы говорим что мы создаем новый Екшен + меняет стейт на новый
// В этом reset мы создаём начальную сортировку(пусть будет по рейтингу), а после этого продукты и продукты мы возьмём из нового стейта
// У нас products: action.initialState, этот инишиалСтейт доступен только если type: reset, благодаря этому когда мы делаем свитч то ТайпСкрипт знает что так как у нас кейс - ресет, то у нас будет доступен этот initialState
